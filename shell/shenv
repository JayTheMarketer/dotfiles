#!/usr/bin/env bash

# locale settings
export LANG=en_US.UTF-8
export LC_ALL=$LANG

# Figure out the SHORT hostname
if [[ "$OSTYPE" = darwin* ]]; then
  # macOS's $HOST changes with dhcp, etc. Use ComputerName if possible.
  SHORT_HOST=$(scutil --get ComputerName 2>/dev/null) || SHORT_HOST=${HOST/.*/}
else
  # Disable ShellCheck "___ appears unused. Verify it or export it." warning:
  # shellcheck disable=SC2034
  SHORT_HOST=${HOST/.*/}
fi

# Set default blocksize for ls, df, du
export BLOCKSIZE=1k

## Command history configuration
if [ -z "${HISTFILE}" ]; then
  if [[ ${SHELL} == $(which zsh) ]]; then
    HISTFILE=~/.zsh_history
  elif [[ ${SHELL} == $(which bash) ]]; then
    HISTFILE=~/.bash_history
  else
    HISTFILE=~/.sh_history
  fi
fi

export HISTSIZE=30000 # sh history will save N commands
export HISTFILESIZE=${HISTSIZE} # sh will remember N commands
export HISTCONTROL=ignoreboth # ingore duplicates and spaces
export HISTIGNORE='&:ls:ll:la:cd:exit:clear:history'

# Show history
case ${HIST_STAMPS} in
  "mm/dd/yyyy") alias history='fc -fl 1' ;;
  "dd.mm.yyyy") alias history='fc -El 1' ;;
  "yyyy-mm-dd") alias history='fc -il 1' ;;
  *) alias history='fc -l 1' ;;
esac

###############################################################################
############################# UTILITY FUNCTIONS ###############################
###############################################################################
#
# Note: these functions must be included prior to the .profile.d or .bashrc.d
# files that use them.
###############################################################################

# Usage:
#   reload
#
# Description:
#   Reload the shell (i.e. invoke as a login shell).
reload() {
  echo "reloading ${SHELL}" && exec "${SHELL}" -l
}

# OS Tests
###############################################################################

# Check for OS
# Usage eg. `is_macos || is_linux`
# Example returns: 0 if current OS is macos || linux
# Example returns: 1 if not.

is_macos() {
  [[ "${OSTYPE}" =~ ^darwin ]]
}

is_osx() {
  [[ "${OSTYPE}" =~ ^darwin ]]
}

is_mavericks() {
  is_osx && {
    ___osx_version="$(sw_vers -productVersion | awk -F. '{print $2}')"
    [ "${___osx_version}" -eq "9" ]
  }
}

is_yosemite() {
  is_osx && {
    ___osx_version="$(sw_vers -productVersion | awk -F. '{print $2}')"
   [ "${___osx_version}" -eq "10" ]
 }
}

is_el_capitan() {
  is_osx && {
    ___osx_version="$(sw_vers -productVersion | awk -F. '{print $2}')"
    [ "${___osx_version}" -eq "11" ]
  }
}

is_sierra() {
  is_macos && {
    ___macos_version="$(sw_vers -productVersion | awk -F. '{print $2}')"
    [ "${___macos_version}" -eq "12" ]
  }
}

is_linux() {
  [[ "$(uname -a)" =~ ^Linux ]]
}

is_ubuntu() {
  is_linux && [[ "$(cat /etc/issue 2> /dev/null)" =~ Ubuntu ]]
}

get_os() {
  for ___os in macos ubuntu linux
  do
    if "is_${___os}"
    then
      printf "%s\n" "${___os}"
      return 0
    fi
  done
}


#
# Shell Tests
###############################################################################

# Check for shell
# Usage eg. `is_zsh`
# Example returns: 0 if current shell is zsh
# Example returns: 1 if not.

is_zsh() {
  [ -n "${ZSH_NAME}" ]
}

is_bash() {
  [ -n "${BASH}" ]
}

is_fish() {
  [ -n "${FISH_VERSION}" ]
}


#
# Command Test
###############################################################################

# Description:
#   If the given command name exists, return 0, otherwise return 1.
# Usage:
#   command_exists "name"
#
#   For information on why `which` is not being used, see:
#   http://stackoverflow.com/a/677212
command_exists() {
  hash "${1}" 2>/dev/null
}
# For compatibiity, alias this function's previous name, `program_exists`.
alias program_exists="command_exists"


#
# source_dir
###############################################################################

# source_dir()
#
# Usage:
#   source_dir <path/to/directory>
#
# Description:
#   Source each of the files in a given directory.
source_dir() {
  if (($#)) && [ -d "${1}" ]
  then
    for ___file in "${1}"/*
    do
      if [ -f "${___file}" ]
      then
        # https://github.com/koalaman/shellcheck/wiki/SC1090
        # shellcheck source=/dev/null
        source "${___file}"
      fi
    done
  else
    printf "Usage: source_dir <path/to/directory>\n"
    return 1
  fi
}

###############################################################################
################################### DEBUG #####################################
###############################################################################

# Set `$_DEBUG_ENABLED` is it's blank.
if [[ -z "${_DEBUG_ENABLED:-}" ]]
then
  export _DEBUG_ENABLED=0
fi

debug() {
  _print_debug_help() {
    cat <<HEREDOC
Usage:
  debug ( on | off | status )
  debug -h | --help

Options:
  -h --help  Show this help.

Description:
  Turn debug mode on or off.
HEREDOC
  }

  for ___arg in "${@:-}"
  do
    case "${___arg}" in
      on)
        _DEBUG_ENABLED=1
        debug status
        ;;
      off)
        _DEBUG_ENABLED=0
        debug status
        ;;
      status)
        if ((_DEBUG_ENABLED))
        then
          printf "on\n"
        else
          printf "off\n"
        fi
        ;;
      -h|--help)
        _print_debug_help
        return 0
        ;;
      *)
        _print_debug_help
        return 1
        ;;
    esac
  done
}

# _debug()
#
# Usage:
#   _debug printf "Debug info. Variable: %s\n" "$0"
#
# A simple function for executing a specified command if the `$_DEBUG_ENABLED`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
_debug() {
  if [[ "${_DEBUG_ENABLED:-"0"}" -eq 1 ]]
  then
    # Prefix debug message with "bug (U+1F41B)"
    printf "🐛  "
    "$@"
    printf "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n"
  fi
}

###############################################################################
##################################### INIT ####################################
###############################################################################

# Add `${HOME}/bin` to $PATH
#
# Prepend `$HOME/bin` to `$PATH` at beginning of initialization so its
# executables are available.
export PATH="${HOME}/bin:${PATH}"

# .shenv.local
#s
# Stash your environment variables in ${HOME}/.shenv.local
# This means they'll stay out of your main dotfiles repository
# (which may be public, like this one), but
# you'll have access to them in your scripts.
if [ -f "${HOME}/.shenv.local" ]; then
  source "${HOME}/.shenv.local"
fi

# load path variables
if [ -f "${DOTFILES}/shell/load_path" ]; then
  source "${DOTFILES}/shell/load_path"
fi

# Add `/usr/local/bin` to $PATH
#
# Make homebrew packages accessible
export PATH="/usr/local/sbin:/usr/local/bin:${PATH}"

# Re-add `${HOME}/bin` to $PATH
#
# Other paths are prepended to `$PATH` during shared_env initialization,
# placing `$HOME/bin` further down the chain. `$HOME/bin` is intended to be at
# the beginning of `$PATH` so the executables it contains have the highest
# precedence. Therefore, it must be re-prepended after the shared environment
# initialization process has been completed.
export PATH="${HOME}/bin:${PATH}"

# Set env programs
#
export ROOT='sudo'
export VISUAL='$EDITOR'

if which nvim >/dev/null; then
  export EDITOR='nvim'
else
  export EDITOR='vim'
fi

# FZF

if which fzf >/dev/null; then
  # using fd (https://github.com/sharkdp/fd)
  if which fd >/dev/null; then
    export FZF_DEFAULT_COMMAND="fd . $HOME"
    export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
    export FZF_ALT_C_COMMAND="fd -t d . $HOME"
  fi

  # using tree (http://mama.indstate.edu/users/ice/tree/)
  export FZF_CTRL_R_OPTS="--preview 'echo {}' --preview-window down:3:hidden:wrap --bind '?:toggle-preview'"

  export FZF_ALT_C_OPTS="--preview 'tree -C {} | head -200'"

  # Using highlight (http://www.andre-simon.de/doku/highlight/en/highlight.html)
  export FZF_CTRL_T_OPTS="--preview '(highlight -O ansi -l {} 2> /dev/null || cat {} || tree -C {}) 2> /dev/null | head -200'"

fi

###############################################################################
################################## COLORS #####################################
###############################################################################

# ANSI Color
# Attributes are in #;#;#...;#
# 0 reset, 1 bold, 4 underline, 5 flashing, 7 inverse
# Text
# 30 black, 31 red, 32 green, 33 yellow, 34 blue, 35 magenta, 36 cyan, 37 white
# Background colors are 40-47
# 100-107 are lighter variants
ANSI_RESET="\033[0;0m"
ANSI_BOLD="\033[1;1m"
ANSI_UNDERLINE="\033[4;4m"
ANSI_FLASH="\033[5;5m"
ANSI_INVERSE="\033[7;7m"

# text colors
ANSI_BLACK="\033[30;30m"
ANSI_RED="\033[31;31m"
ANSI_GREEN="\033[32;32m"
ANSI_YELLOW="\033[33;33m"
ANSI_BLUE="\033[34;34m"
ANSI_MAGENTA="\033[35;35m"
ANSI_CYAN="\033[36;36m"
ANSI_WHITE="\033[36;36m"

# background colors
ANSI_BG_BLACK="\033[40;40m"
ANSI_BG_RED="\033[41;41m"
ANSI_BG_GREEN="\033[42;42m"
ANSI_BG_YELLOW="\033[43;43m"
ANSI_BG_BLUE="\033[44;44m"
ANSI_BG_MAGENTA="\033[45;45m"
ANSI_BG_CYAN="\033[46;46m"
ANSI_BG_WHITE="\033[47;47m"

# Configure colors, if available.
if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
  c_reset='\[\e[0m\]'
  # c_user='\[\033[1;33m\]'
  # c_path='\[\e[0;33m\]'
  # c_git_clean='\[\e[0;36m\]'
  # c_git_dirty='\[\e[0;35m\]'
  c_user=${ANSI_CYAN}
  c_path=${ANSI_LIGHT_BLUE}
  c_git_clean=${ANSI_LIGHT_GREEN}
  c_git_dirty=${ANSI_LIGHT_RED}
else
  c_reset=
  c_user=
  c_path=
  c_git_clean=
  c_git_dirty=
fi

# Yes, these are a pain to customize. Fortunately, Geoff Greer made an online
# tool that makes it easy to customize your color scheme and keep them in sync
# across Linux and OS X/*BSD at http://geoff.greer.fm/lscolors/

export CLICOLOR=1
export CLICOLOR_FORCE=1

# check for GNU dircolors
if type gdircolors >/dev/null; then
  alias dircolors=gdircolors
fi

if [[ -r ${HOME}/.dircolors ]]; then
  eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
else
  export LSCOLORS="exfxcxdxbxegedabagacad"
  export LS_COLORS='di=34:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43';
fi

if [[ -f /usr/local/etc/grc.bashrc ]]; then
  source /usr/local/etc/grc.bashrc
fi

###############################################################################
################################### LOADED ####################################
###############################################################################
#
# SHENV_LOADED
#
# Available to other files in the initialization process to use in order to
# determine whether this shared environment has been loaded.
#
# This variable *should not be exported*, since subshells need to be able to
# run through the initialization process themselves, and this variable would
# prevent that.
#
# Disable ShellCheck "___ appears unused. Verify it or export it." warning:
# shellcheck disable=SC2034
SHENV_LOADED=true
